# 3面试题-架构设计

[TOC]

## 一、谈架构

#### 1. 谈谈对移动端架构的理解？

[1. 组件化](../06架构与设计/1组件化.md)

[2. 插件化](../06架构与设计/2插件化.md)

[3. 热修复](../06架构与设计/3热修复.md)

#### 2. Glide 图片缓存设计？图片滚出屏幕后怎么处理的？

- 缓存设计

  1. 活动缓存(弱引用)；

     存储正在显示的图片，图片移除屏幕或关闭当前界面图片都会保存到内存缓存。

     对资源添加了引用计数器，当屏幕中都不引用资源时，移除到内存缓存。

  2. 内存缓存(有最大Size、强引用LruCache&LinkedHashMap);

  3. 资源缓存(解码后的图片、LruCache)；

  4. 原始缓存(LruCache)；

- ListView图片滚出屏幕处理？

  活动缓存只会存储当前界面上对应item上的图片，item移除屏幕，当ImageView复用时，会先清空它对应的活动缓存的值(移动到内存缓存)，然后再加载新图片到活动缓存(活动缓存会一直保存6个item对应的资源)。

#### 3.ListView、RecycleView 区别？

- 都用适配器设计模式

  解耦View和数据源，为View提供统一数据读取方法。

- RecycleView 代码设计更精细化、功能化

  ```java
  LayoutManager  // 负责Item视图布局显示管理(支持多种布局显示)
  ItemDecoration // 添加分割线
  RecyclerView.Adapter
  BadgeGateUsersAdapter.ViewHolder
  RecyclerView.Recycler // 负责管理缓存  
  ```

- 缓存设计区别(**ListView 二级缓存、RecyclerView四级缓存**)

  **缓存级别设计区别：**

  1. scrap:      对应listView的一级缓存(屏幕内显示的)

  2. cached:   对应listView的二级缓存(移除屏幕的)

    linearlayoutmanager来说cached缓存默认大小为2，起到的作用就是rv滑动时刚被移出屏幕的viewholer的收容所。

  3. extension:    三级缓存

      第三级缓存，这是一个自定义的缓存，没错rv是可以自定义缓存行为的

  目前来说这还只是个空实现而已，从这点来看其实rv所说的四级缓存本质上还只是三级缓存。

  pool：    四级缓存

   pool一般会和cached配合使用，这么来说，cached存不下的会被保存到pool中毕竟cached默认容量大小只有2，但是pool容量       也是有限的当保存满之后再有viewholder到来的话就只能会无情抛弃掉，它也有一个默认的容量大小5.

  **其他区别：**

  1. ListView缓存的是View，而RV存储的是ViewHolder；
  2. cached如果命中，可以直接复用，无需createVew和bindView(item划出立即划入场景，listview不能立即使用)；
  3. RecycleViewPool可以共用多个相同Adapter的ViewHolder，避免重复销毁和创建(场景：ViewPager+多个RV等)。

- RV支持局部刷新

  ```java
  // rv实现
  mRvAdapter.notifyItemChanged(1);
  // listView实现局部刷新(调用getView方法)
  //我们通过ListView的getChildAt()来获得需要更新的View，然后通过getTag()获得ViewHolder，从而实现更新。
  /**
       * 更新对应view的内容
       * @param name
       * @param position
       */
      private void updateName(String name, int position) {
          int firstVisiblePosition = listview.getFirstVisiblePosition();
          int lastVisiblePosition = listview.getLastVisiblePosition();
          //在看见范围内才更新进度条
          if (position >= firstVisiblePosition && position <= lastVisiblePosition) {
              //获取指定位置view对象!!!
              View view = listview.getChildAt(position - firstVisiblePosition);
              if (view.getTag() instanceof TestListViewAdapter.ViewHolder) {
                  //获取指定view对应的ViewHolder!!!
                  TestListViewAdapter.ViewHolder viewHolder = (TestListViewAdapter.ViewHolder) view.getTag();
                  viewHolder.name.setText(name);
              }
          }
      }
  ```

- 数据源改变时处理区别

  ListView和RecyclerView最大的区别在于数据源改变时的缓存的处理逻辑，ListView是”一锅端”，将所有的mActiveViews都移入了二级缓存mScrapViews(**都需要重新bindview**)，而RecyclerView则是更加灵活地对每个View修改标志位，**区分是否重新bindView**。

#### 4. Arouter

#### 5. OkHttp

#### 6. Retrofit



## 二、谈设计

#### 1. 从一个有100w个手机号的文件中，从头匹配手机号搜索设计(1、13、135对应的手机号)？

1. 100W个手机号加载到内存，大约占10M空间，存储为数组结构；
2. 遍历数组，首位数字为0的存在一个Map中，key为”0“，value为”对应的数组下标“，然后是首位为1到9的同样处理；以此类推，处理第2-11位手机号，共生成10*11=110个Map；
3. 用户输入首位为1，则查找首位对应key为1的Map，得到首位为1的下标数组；用户继续输入3，则查找第二位为3的Map，得到第二位为3的下标数组；找到两个数组的交集，结果为13开头的手机号下标数组。依次查找后序手机号即可。

  空间复杂度为10M，时间复杂度 每位查找基本上递减1/10；

#### 2. 响应式编程

1. [Rxjava](../06架构与设计/10Rxjava.md)
2. [Jetpack](../06架构与设计/5Jetpact.md)
3. ReactNative

#### 3. 协程