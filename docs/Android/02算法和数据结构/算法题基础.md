### ç®—æ³•é¢è¯•é¢˜-åŸºç¡€

[TOC]

[æ–‡ç« 1](https://leetcode-cn.com/circle/discuss/AfJAq7/)

[æ–‡ç« 2](https://www.jianshu.com/p/c70989bd5f29)

[æ–‡ç« 3](https://www.jianshu.com/p/b08413d5bdb5)

[æ–‡ç« 4](https://www.sohu.com/a/256897604_100231250)

[æ–‡ç« 5](https://leetcode-cn.com/circle/discuss/CdPmqz/)

> æ³¨æ„äº‹é¡¹ï¼š
>
> 	1. æŒç»­ç»ƒä¹ ã€ç²¾æ·±ç»ƒä¹ ã€‚
>  	2. åˆ‡é¢˜å››ä»¶å¥—ã€‚
>  	3. æ²Ÿé€šå’Œäº¤æµå¾ˆé‡è¦ã€‚

#### ä¸€ã€ç»¼åˆé¢˜ç›®

##### 1. æŸ¥æ‰¾æ•°ç»„ä¸­çš„é‡å¤æ•°å­—

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**

**æ€è·¯(æŸ¥é‡å¤)ï¼š**

1. åˆ©ç”¨HashSeté›†åˆ

   åˆ©ç”¨å“ˆå¸Œè¡¨ç‰¹æ€§ã€‚

   å¤æ‚åº¦ï¼šO(N)ã€O(N)ã€‚

2. éå†å¯¹æ¯”

   æš´åŠ›ç ´è§£ï¼Œéå†ä¾æ¬¡ä¸å‰é¢æ‰€æœ‰å…ƒç´ å¯¹æ¯”ã€‚

   å¤æ‚åº¦ï¼šO(n(n+1)/2çº¦ç­‰äºn^2)ï¼ŒO(1)ã€‚

3. æ’åº

   å…ˆå¿«æ’ï¼Œå†éå†ã€‚

   å¤æ‚åº¦ï¼šO(N$\log$N+Nçº¦ç­‰äºNLogN)ã€O(logN)ã€‚

4. åŸåœ°ç½®æ¢(æŠ½å±‰åŸç†) **æœ€ä¼˜è§£**

   åˆ©ç”¨æ•°ç»„å…ƒç´ ç‰¹å¾ï¼Œ`æ•°å­—num[i]åº”è¯¥æ”¾åœ¨ä¸‹æ ‡ä¸ºiçš„ä½ç½®ä¸Š`ã€‚

   å¤æ‚åº¦ï¼šO(N)ã€O(1)ã€‚

   **åŒºåˆ«ï¼š**1ã€2ä¸éœ€è¦éœ€æ”¹åŸæ•°ç»„ï¼Œ3ï¼Œ4éœ€è¦ä¿®æ”¹ã€‚

```java
//1. éå†å¯¹æ¯”
int[] arrays = {2, 3, 1, 0, 2, 5, 3};
jump:for (int i=0;i<arrays.length;i++) {
  int value = arrays[i];
  for (int j=0;j<i;j++){Ã¥
    if(value == arrays[j]){
      System.out.println("æ‰¾åˆ°äº†" + value);
      break jump;
    }
  }
}
//2. ä½ç½®äº¤æ¢
int temp;
for (int i=0;i<nums.length;i++){
  if(i == nums[i]){
    continue;
  }

  temp = nums[nums[i]];
  if(temp == nums[i]){
    System.out.println("æ‰¾åˆ°äº†" + temp);
    break;
  }

  nums[nums[i]] = nums[i];
  nums[i] = temp;
  i--;
}
//3. å¿«æ’
```

##### 2. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­—Iå‡ºç°çš„æ¬¡æ•°

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)**

**æ€è·¯(æŸ¥é‡å¤ã€äºŒåˆ†)ï¼š**

1. äºŒåˆ†æŸ¥æ‰¾ï¼Œå·¦å³åˆ†åˆ«æŸ¥æ‰¾ã€‚

   æ—¶é—´å¤æ‚åº¦O(NlogN+Nçº¦ç­‰äºNlogN)ï¼Œç©ºé—´å¤æ‚åº¦O(logN)ã€‚

```java
 public static int findNumberInArrayRepeat(int[] nums, int number, int left, int right) {
        int valueIndex = binarySearch(nums, 0, left, right);

        int repeatNumber = 0;
        if (valueIndex == -1) {
            return repeatNumber;
        }

        for (int i = valueIndex; i >= 0; i--) {
            if (nums[i] == number) {
                repeatNumber++;
                continue;
            }
            break;
        }

        for (int i = valueIndex + 1; i < nums.length; i++) {
            if (nums[i] == number) {
                repeatNumber++;
                continue;
            }
            break;
        }

        return repeatNumber;
    }

		// äºŒåˆ†æŸ¥æ‰¾å…ƒç´ ç´¢å¼•
    public static int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1; // æ³¨æ„

        while (left <= right) { // æ³¨æ„
            int mid = (right + left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1; // æ³¨æ„
            else if (nums[mid] > target)
                right = mid - 1; // æ³¨æ„
        }
        return -1;
    }
```

##### 3. äºŒç»´æ•°ç»„çš„æŸ¥æ‰¾

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)**

**æ€è·¯(æ‰¾è§„å¾‹)ï¼š**

1. å³ä¸Šè§’å…ƒç´  å¤§äºå·¦è¾¹å€¼ï¼Œå°äºä¸‹è¾¹å€¼(æˆ–å³ä¸‹è§’)ã€‚

   æ—¶é—´å¤æ‚åº¦O(n+m)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. æš´åŠ›å¾ªç¯ï¼Œå…¨éƒ¨éå†ã€‚

   æ—¶é—´å¤æ‚åº¦O(n*m)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

3. äºŒåˆ†+åˆ—å¾ªç¯ã€‚

   éå†æ¯”è¾ƒæ‰¾æ¯ä¸€è¡Œæœ€å¤§å€¼ï¼Œæ‰¾åˆ°targetå°äºæœ€å¤§å€¼çš„ä¸€è¡Œï¼›

   äºŒåˆ†éå†è¯¥è¡Œï¼Œæ‰¾åˆ°ç›¸é‚»çš„æ¯”targetå°çš„å…ƒç´ Index;

   ä»è¯¥è¡Œå¼€å§‹ï¼ŒæŒ‰åˆ—éå†æ¯”è¾ƒIndexçš„å…ƒç´ ï¼Œç›´åˆ°åŒ¹é…æˆåŠŸã€‚

   æ—¶é—´å¤æ‚åº¦å¤§æ¦‚æ˜¯O(logN+Mæˆ–N+logM);

```java
// äºŒä½æ•°ç»„
int[][] arrays = {
                {1, 4, 7, 11, 15},
                {2, 5, 8, 12, 19},
                {3, 6, 9, 16, 22},
                {10, 13, 14, 17, 24},
                {18, 21, 23, 26, 30}
        };
        
int target = 6;
int row = arrays.length;
int col = arrays[0].length;

// å³ä¸Šè§’ä¸ºèµ·ç‚¹ï¼Œä¾æ¬¡æ’é™¤è¡Œåˆ—(åˆ†æè§„å¾‹ï¼Œæ‰¾å¯¹èµ·ç‚¹)
for (int i=0,j=arrays[0].length-1;(i>=0 && i<row) && (j>=0 && j<col);){
  if(target == arrays[i][j]){
    System.out.println("æ‰¾åˆ°äº†"+i + " " + j);
    break;
  }else if(target < arrays[i][j]){
    j--;
  }else{
    i++;
  }
}

```

##### 4. æ›¿æ¢ç©ºæ ¼

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)**

è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼ŒæŠŠå­—ç¬¦ä¸² `s` ä¸­çš„æ¯ä¸ªç©ºæ ¼æ›¿æ¢æˆ"%20"ã€‚

**æ€è·¯ï¼š**

1. åˆ©ç”¨replaceæˆ–splitå‡½æ•°æˆ–urlencoderç›´æ¥å¤„ç†ã€‚

   ç©ºé—´å¤æ‚åº¦å’Œæ—¶é—´å¤æ‚åº¦å¤ªé«˜ã€‚

2. éå†ï¼Œåˆ©ç”¨StringBufferæ‹¼æ¥æ•°æ®ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

3. æ„å»ºä¸€ä¸ª3å€é•¿åº¦æ•°ç»„(å¯ä¼˜åŒ–)ï¼Œéå†å³å¯ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(3n)ã€‚

```java
// æ¨èä½¿ç”¨urlecodeã€replaceã€StringBufferè§£å†³ã€‚
public static void main(String[] args) {
        String test = "We are happy.";
        // æ–°count
        int newSize = test.length();
        for (int i=0;i< test.length();i++){
            if(test.charAt(i) == ' '){
                newSize +=2;
            }
        }

        // éå†èµ‹å€¼
        char[] newTest = new char[newSize];
        int tempJumpIndex=0; // æ³¨æ„ç´¢å¼•è·³è¿‡
        for (int i=0;i< test.length();i++) {
            if(test.charAt(i) == ' '){
                newTest[i+tempJumpIndex] = '%';
                newTest[i+tempJumpIndex+1] = '2';
                newTest[i+tempJumpIndex+2] = '0';
                tempJumpIndex +=2;
            }else {
                newTest[i+tempJumpIndex] =test.charAt(i);
            }
        }

        System.out.println(newTest);
    }
```



#### äºŒã€é“¾è¡¨

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/reverse-linked-list/)**

**æ€è·¯ï¼š**

1. æš´åŠ›éå†åˆ°æ–°é“¾è¡¨å¤´

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. å¤´æ’å…¥æ³•(æœ€ç®€æ´)

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

3. é€’å½’å¤„ç†

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

##### 1. åè½¬é“¾è¡¨(ä»å°¾åˆ°å¤´æ‰“å°)

```java
// 1. æ€æƒ³ï¼šå¤´æ’å…¥æ³•
public static Node reverseByInsert(Node headNode){
        Node temp;
        Node newHead = null;
        while (headNode != null){
            temp = headNode;
            headNode = headNode.next;
            
            temp.next = newHead;
            newHead = temp;
        }
        return newHead;
}

 //2. å¼ºåˆ¶ å¾ªç¯å¤„ç†
    public static Node reverseLinkedNode(Node head) {
        Node newNode = new Node(-1, null);

        while (head != null) {
            Node tempNext = head.next;
            head.next = newNode.next;
            newNode.next = head;

            head = tempNext;
        }

        return newNode.next;
    }
// 3. æ€æƒ³ï¼šé€’å½’åˆ°å°¾éƒ¨ï¼Œä¾æ¬¡ç¿»è½¬æ–­é“¾
public static Node reverse(Node headNode){
        if(headNode == null || headNode.next == null){
            return headNode;
        }

        Node newNode = reverse(headNode.next);
        headNode.next.next = headNode;  // nodeç¿»è½¬
        headNode.next = null;           // æ–­é“¾
        return newNode;
}
```



##### 2. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)**

**æ€è·¯ï¼š**

1. æš´åŠ›éå†ç ´è§£

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. åˆ©ç”¨æ ˆè§£å†³

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

3. é€’å½’å¤„ç†(æœ€ç®€å•)

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

```java
//1. æš´åŠ›éå†ç ´è§£
public static Node swapPairsLinkedNode(Node node) {
        if (node == null || node.next == null) {
            return node;
        }

        Node newNode = node.next;
        Node pre = null;
        while (node != null && node.next != null) {
            Node tempNext = node.next.next;
            if (pre != null) {
                // ä¸preé“¾ä¸Š
                pre.next = node.next;
            }

            node.next.next = node; // 2æŒ‡1
            node.next = tempNext;  // 1æŒ‡3

            pre = node;
            node = tempNext;
        }

        return newNode;
    }
//2. é€’å½’
public static Node swapPairsNew(Node head) {  // 3
        if (head == null || head.next == null) {
            return head;
        }
        Node newHead = head.next;  // 4 ä¿ç•™nextå€¼
        head.next = swapPairsNew(newHead.next) // 5;  3æŒ‡å‘5ï¼Œç„¶å4æŒ‡å‘3ï¼Œè¿”å›4  
        newHead.next = head;
        return newHead;
    }
```

##### 3. åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/linked-list-cycle/)**

**æ€è·¯ï¼š**

1. å¿«æ…¢æŒ‡é’ˆ

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. HashSet

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

3. æš´åŠ›å¾ªç¯5sï¼Œçœ‹å¾ªç¯æ˜¯å¦ç»ˆæ­¢ã€‚

```java
public static Node detectCycleInter(Node head) {
        Node fast = head, slow = head;
        while (true) {
            if (fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
  			// æŸ¥æ‰¾å…¥ç¯èŠ‚ç‚¹(ç¢°æ’ä½ç½®å’Œheadä¸€èµ·nextéå†ï¼Œç›¸é‡çš„ä½ç½®å°±æ˜¯å…¥ç¯èŠ‚ç‚¹)
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
```



##### 4. è¿”å›ç¯å½¢é“¾è¡¨å…¥ç¯èŠ‚ç‚¹

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/linked-list-cycle-ii/)**

**æ€è·¯ï¼š**

1. åˆ©ç”¨æ•°å­¦å‘¨é•¿åŸç†(å‘¨é•¿ç­‰äºn)

   å‘ç”Ÿç¢°æ’çš„ä½ç½®å’Œèµ·ç‚¹ä¾æ¬¡å‘åéå†ï¼Œç›¸é‡çš„åœ°æ–¹å°±æ˜¯å…¥ç¯èŠ‚ç‚¹ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. HashSet

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

   ä»£ç åœ¨ä¸Šé¢ğŸ‘†ã€‚

#### ä¸‰ã€æ ˆå’Œé˜Ÿåˆ—

##### 1. æœ‰æ•ˆçš„æ‹¬å·("({[]})")

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/valid-parentheses/)**

**æ€è·¯ï¼š**

1. åˆ©ç”¨æ ˆç‰¹æ€§ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. åˆ©ç”¨replaceå‡½æ•°

   å¾ªç¯replace("()") || replace("[]")ã€‚

3. æ ˆå˜ç§å®ç°LinkedList

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

```java
 public static boolean isValidStr(String str) {
        boolean result = true;
        HashMap<Character, Character> data = new HashMap<>();
        data.put(')', '(');
        data.put(']', '[');
        data.put('}', '{');

        Stack<Character> stack = new Stack<>();

        for (int i = 0; i < str.length(); i++) {
            char s = str.charAt(i);

            if (!data.containsKey(s)) {
                stack.push(s);
            } else {
                if (stack.pop() != data.get(s)) {
                    result = false;
                    break;
                }

            }
        }

        return result;
    }

//2. LinkedListå®ç°
 public boolean isValidNew(String s) {
        LinkedList<Character> stack = new LinkedList<>();
        for (char c : s.toCharArray()) {
            if (c == '[') stack.push(']');
            else if (c == '(') stack.push(')');
            else if (c == '{') stack.push('}');
            else if (stack.isEmpty() || c != stack.pop()) return false;
        }
        return stack.isEmpty();
    }
```

##### 2. ç”¨æ ˆå®ç°é˜Ÿåˆ—

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/implement-queue-using-stacks/)**

**æ€è·¯ï¼š**

1. ä¸¤ä¸ªæ ˆå®ç°(æ³¨æ„å¹¶å‘é—®é¢˜)ã€‚

   ä¸€ä¸ªå…¥æ ˆä¸€ä¸ªå‡ºç«™ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

##### 3. ç”¨é˜Ÿåˆ—å®ç°æ ˆ

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/implement-stack-using-queues/)**

**æ€è·¯ï¼š**

1. ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—LinkedListå®ç°(æˆ–æ¯æ¬¡æŠŠå…ƒç´ æ”¾å‰é¢)ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. ä¸¤ä¸ªé˜Ÿåˆ—å®ç°

   ä¸¤ä¸ªé˜Ÿåˆ—ç›¸äº’å€’è…¾ï¼Œæ–°å…ƒç´ æ¯æ¬¡æ’å…¥æ–°é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªï¼Œç„¶ååŒ…æ—§é˜Ÿåˆ—ä¾æ¬¡æ”¾å…¥æ–°é˜Ÿåˆ—ã€‚

```java
//1. ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—å®ç°
 LinkedList<Integer> linkedList = new LinkedList<Integer>();
  linkedList.addFirst(1);
  linkedList.addFirst(2);
  linkedList.addFirst(3);
  linkedList.addFirst(4);
  linkedList.addFirst(5);

  System.out.println(linkedList.removeFirst());
  System.out.println(linkedList.removeFirst());
  System.out.println(linkedList.removeFirst());
  System.out.println(linkedList.removeFirst());
//2. ä¸€ä¸ªé˜Ÿåˆ—å®ç°ï¼Œæ¯æ¬¡æ’å…¥å…ƒç´ æ”¾æœ€å‰é¢ã€‚
  Queue<Integer> queue = new LinkedList<Integer>();

  public void push(int x) {
        int n = queue.size();
        queue.offer(x);
        for (int i = 0; i < n; i++) {
            queue.offer(queue.poll());
        }
  }
//3. äºŒä¸ªé˜Ÿåˆ—å®ç°
static class MyStack {
        Queue<Integer> queue1 = new LinkedList<>();
        Queue<Integer> queue2 = new LinkedList<>();
        MyStack(){}

        public void push(int value) {
            if (queue1.size() == 0) {
                queue1.offer(value);
                while (queue2.size() > 0) {
                    queue1.offer(queue2.poll());
                }
            } else {
                queue2.offer(value);
                while (queue1.size() > 0) {
                    queue2.offer(queue1.poll());
                }
            }
        }
  
        public int pop() {
            if (queue1.size() > 0) {
                return queue1.poll();
            } else if (queue2.size() > 0) {
                return queue2.poll();
            }
            return -1;
        }
    }
```

#### å››ã€ ä¼˜å…ˆé˜Ÿåˆ—

å †å®ç°ï¼šäºŒå‰å †(jdké»˜è®¤**å°é¡¶å †å®ç°PriorityQueue**)ã€æ–æ³¢æ‹‰å¥‘å †(æ•ˆç‡æœ€é«˜)ç­‰ã€‚

å †å®ç°åŒºåˆ«ï¼š

![å †å®ç°](images/struct-heap.png)

##### 1. ä¼˜å…ˆé˜Ÿåˆ—æ’åº

**æ€è·¯ï¼š**

â€‹	é»˜è®¤æŒ‰å­—å…¸æ’åºï¼Œä¹Ÿå¯ä»¥ä¼ å…¥å¯¹è±¡æ¯”è¾ƒå™¨ã€‚

```java
public static void main(String[] args) {
        //ä¼˜å…ˆé˜Ÿåˆ—è‡ªç„¶æ’åºç¤ºä¾‹
        Queue<Integer> integerPriorityQueue = new PriorityQueue<>(7);
        Random rand = new Random();
        for(int i=0;i<7;i++){
            integerPriorityQueue.add(new Integer(rand.nextInt(100)));
        }

        for(int i=0;i<7;i++){
            Integer in = integerPriorityQueue.poll();
            System.out.println("Processing Integer:"+in);
        }
  
        //è‡ªå®šä¹‰æ’åºä¼˜å…ˆé˜Ÿåˆ—ä½¿ç”¨ç¤ºä¾‹
        Queue<Customer> customerPriorityQueue = new PriorityQueue<>(7, idComparator);
        addDataToQueue(customerPriorityQueue);
        pollDataFromQueue(customerPriorityQueue);
    }
    //åŒ¿åComparatorå®ç°
    public static Comparator<Customer> idComparator = new Comparator<Customer>(){
        @Override
        public int compare(Customer c1, Customer c2) {
            return (int) (c1.getId() - c2.getId());
        }
    };
    //ç”¨äºå¾€é˜Ÿåˆ—å¢åŠ æ•°æ®çš„é€šç”¨æ–¹æ³•
    private static void addDataToQueue(Queue<Customer> customerPriorityQueue) {
        Random rand = new Random();
        for(int i=0; i<7; i++){
            int id = rand.nextInt(100);
            customerPriorityQueue.add(new Customer(id, "Pankaj "+id));
        }
    }
    //ç”¨äºä»é˜Ÿåˆ—å–æ•°æ®çš„é€šç”¨æ–¹æ³•
    private static void pollDataFromQueue(Queue<Customer> customerPriorityQueue) {
        while(true){
            Customer cust = customerPriorityQueue.poll();
            if(cust == null) break;
            System.out.println("Processing Customer with ID="+cust.getId());
        }
    }
```

##### 1. æ•°æ®æµä¸­ç¬¬Kå¤§å…ƒç´ 

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)**

**æ€è·¯ï¼š**

1. PriorityQueueå°é¡¶å †å®ç°

   ç»´æŠ¤Kä¸ªå…ƒç´ ï¼Œæœ€å°çš„åœ¨æœ€ä¸Šé¢ã€‚

   æ—¶é—´å¤æ‚åº¦N*logKï¼Œç©ºé—´å¤æ‚åº¦O(K)ã€‚

2. æ¯”è¾ƒå¿«æ’å‰Kå¤§ä¸ªå…ƒç´ ã€‚

   æ—¶é—´å¤æ‚åº¦N*KlogKï¼Œç©ºé—´å¤æ‚åº¦O(logN)ã€‚

```java
// 1. åˆ©ç”¨å°é¡¶å †ç»´æŠ¤
static class KthLargest {
        int k;
        PriorityQueue<Integer> priorityQueue;

        KthLargest(int k, int[] nums) {
            this.k = k;
            priorityQueue = new PriorityQueue<>();
            init(nums);
        }

        private void init(int[] nums) {
            for (int i = 0; i < nums.length; i++) {
                priorityQueue.add(nums[i]);

                if (i >= k) {
                    priorityQueue.poll();
                }
            }
        }

        public int getKValue() {
            return priorityQueue.peek();
        }

        public int add(int val) {
            if (val <= getKValue()) {
                return getKValue();
            }

            priorityQueue.poll();
            priorityQueue.add(val);

            return getKValue();
        }
    }
```



##### 2. æ»‘åŠ¨çª—å£æœ€å¤§å€¼

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/sliding-window-maximum/)**

**æ€è·¯ï¼š**

1. åˆ©ç”¨å¤§é¡¶å †(å°é¡¶å †åŠ æ¯”è¾ƒå™¨å®ç°)

   æ¯ä¸ªçª—å£çš„å€¼éƒ½æ”¾å…¥å¤§é¡¶å †ã€‚

   æ—¶é—´å¤æ‚åº¦O(N*logK),ç©ºé—´å¤æ‚åº¦O(logK)ã€‚

2. åˆ©ç”¨åŒç«¯é˜Ÿåˆ—å®ç°LinkedList

   ç»´æŠ¤å·¦è¾¹æ˜¯æœ€å¤§å€¼ï¼Œä¿å­˜å…¶ç´¢å¼•(å¯ä»¥åˆ é™¤éƒ¨åˆ†æ²¡æœ‰å‡ºå¤´ä¹‹æ—¥çš„å…ƒç´ )

   æ—¶é—´å¤æ‚åº¦O(n),ç©ºé—´å¤æ‚åº¦O(K)ã€‚

```java
//1. å¤§é¡¶å †(åˆ©ç”¨å°é¡¶å †åŠ æ¯”è¾ƒå™¨å®ç°)
 public static ArrayList<Integer> maxSlidingWindowNew(int[] nums, int k) {
        ArrayList<Integer> arrayList = new ArrayList<>();
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((o1, o2) -> {
            if (o2.equals(o1)) {
                return 0;
            } else {
                return (o2 - o1) > 0 ? 1 : -1;
            }
        });

        int ignore = 0;
        for (int i = k - 1; i < nums.length; i++) {
            for (int j = i; j >= ignore; j--) {
                priorityQueue.add(nums[j]);
            }
            arrayList.add(priorityQueue.peek());

            ignore++;
            priorityQueue.clear();
        }

        return arrayList;
    }

//2. åŒç«¯é˜Ÿåˆ—
public static ArrayList<Integer> maxSlidingWindowNewLink(int[] nums, int k) {
        ArrayList<Integer> arrayList = new ArrayList<>();
        LinkedList<Integer> linkedList = new LinkedList<>(); // å­˜ç´¢å¼•

        for (int i = 0; i < nums.length; i++) {
            if (i == 0) {
                linkedList.add(i);
                continue;
            }

            // ç»´æŠ¤æ’åºæ•°ç»„ï¼Œå·¦è¾¹æœ€å¤§
            if (nums[i] >= nums[linkedList.getLast()]) {
                linkedList.clear();
                linkedList.add(i);
            } else {
                linkedList.add(i);
            }

            if (i >= (k - 1)) {
                arrayList.add(nums[linkedList.getFirst()]);
								// åˆ é™¤åˆ’å‡ºçš„å…ƒç´ 
                if (linkedList.getFirst() == i - (k - 1)) {
                    linkedList.removeFirst();
                }
            }
        }

        return arrayList;
    }
```

#### å››ã€å“ˆå¸Œè¡¨

##### 1. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯(242)

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/valid-anagram/)**

**æ€è·¯ï¼š**

1. åˆ©ç”¨HashMapå®ç°ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(S)ã€‚

2. æ’åºå®ç°

   æ—¶é—´å¤æ‚åº¦O(NlogN)ï¼Œç©ºé—´å¤æ‚åº¦O(logN)ã€‚

##### 2. ä¸¤æ•°ä¹‹å’Œ

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/two-sum/)**

**æ€è·¯ï¼š**

1. æš´åŠ›å¾ªç¯(ä¾æ¬¡å¾€å‰æ¯”å¯¹)

   æ—¶é—´å¤æ‚åº¦O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. åˆ©ç”¨HashMap

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

```java
    public static int[] towSum(int[] nums,int target){
        HashMap<Integer,Integer> hashMap = new HashMap<>();

        for (int i=0;i<nums.length;i++){

            if(hashMap.containsKey(target - nums[i])){
                return new int[]{hashMap.get(target - nums[i]),i};
            }

            hashMap.put(nums[i],i);
        }

        return new int[]{};
    }
```

##### 3. ä¸‰æ•°ä¹‹å’Œ

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/3sum/)**

**æ€è·¯ï¼š**

1. æš´åŠ›å¾ªç¯(ä¾æ¬¡å¾€å‰æ¯”å¯¹)

   æ—¶é—´å¤æ‚åº¦O(n^3)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. åˆ©ç”¨HashMapå’Œå‰é¢çš„ä¸¤æ•°ä¹‹å’Œ

   æ—¶é—´å¤æ‚åº¦O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

```java
    public static int[] threeSum(int[] nums,int target){
        for (int i=2;i<nums.length;i++){
            int[] towSum = towSum(nums, i,target-nums[i]);
            if(towSum.length == 2){
                return new int[]{towSum[0],towSum[1],i};
            }
        }
        
        return new int[]{};
    }

    public static int[] towSum(int[] nums,int endLenght,int target){
        HashMap<Integer,Integer> hashMap = new HashMap<>();

        for (int i=0;i<endLenght;i++){
            if(hashMap.containsKey(target - nums[i])){
                return new int[]{hashMap.get(target - nums[i]),i};
            }
            hashMap.put(nums[i],i);
        }

        return new int[]{};
    }
```



#### äº”ã€äºŒå‰æ ‘

##### 1. éªŒè¯äºŒå‰æœç´¢æ ‘

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/validate-binary-search-tree/)**

**æ€è·¯ï¼š**

1. ä¸­åºéå†ï¼ŒéªŒè¯ç»“æœæ˜¯å‡åºæ•°ç»„ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

2. é€’å½’ï¼Œå·¦å­æ ‘æœ€å¤§å€¼å°äºrootï¼Œå³å­æ ‘æœ€å°å€¼å¤§äºrootã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

   <img src="images/tree_vaild_bst.png" style="zoom:50%;" />

```java
// ä¸­åºéå†
    public static void inOrderTree(MyTreeNode myTreeNode){
        if(myTreeNode == null){
            return;
        }

        inOrderTree(myTreeNode.leftChild);
        System.out.print(myTreeNode.data + " -> ");
        inOrderTree(myTreeNode.rightChild);
    }
// é€’å½’
 public static void vaildBST(MyTreeNode<Integer> myTreeNode){
        System.out.println(helper(myTreeNode,null,null));
    }

    public static boolean helper(MyTreeNode<Integer> node,Integer lower,Integer upper){
        if (node == null) {
            return true;
        }

        int val = node.data;
        if(lower != null && val <= lower){
            return false;
        }
        if(upper != null && val >= upper){
            return false;
        }

        if(!helper(node.leftChild,lower,val)){
            return false;
        }
        if(!helper(node.rightChild,val,upper)){
            return false;
        }

        return true;
    }

```

##### 2. äºŒå‰æ ‘&äºŒå‰æœç´¢æ ‘æœ€è¿‘å…¬å…±ç¥–å…ˆ

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)**

1. ä¿å­˜æ‰€æœ‰èŠ‚ç‚¹çˆ¶èŠ‚ç‚¹ï¼ŒæŒ‰è·¯å¾„äº¤å‰æŸ¥æ‰¾ã€‚

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

2. é€’å½’æŸ¥æ‰¾

   æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚

```java
  // é€’å½’æŸ¥è¯¢äºŒå‰æ ‘ 
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
}
// é€’å½’æŸ¥è¯¢äºŒå‰æ ‘æœç´¢æ ‘ 
// 1. è¿­ä»£
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root) {
            if (root->val > p->val && root->val > q->val) {
                root = root->left;
            } else if (root->val < p->val && root->val < q->val) {
                root = root->right;
            } else return root;
        }
        return NULL;
    }
//2. é€’å½’
const lowestCommonAncestor = (root, p, q) => {
    if (p.val < root.val && q.val < root.val) {
        return lowestCommonAncestor(root.left, p, q);
    }
    if (p.val > root.val && q.val > root.val) {
        return lowestCommonAncestor(root.right, p, q);
    }
    return root;
};
```

##### 3. äºŒå‰æ ‘å‰åºã€ä¸­åºã€ååºéå†

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)**

æ³¨æ„ï¼šå¦‚æœæ˜¯æœç´¢äºŒå‰æ ‘ï¼Œä¸­åºéå†ä¸ºå‡åºæ•°ç»„ã€‚

```java
// å‰åºéå†
public void preorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorder(root.left, res);
        preorder(root.right, res);
    }
```

##### 4. äºŒå‰æ ‘çš„å±‚åºéå†

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)**

**æ€è·¯ï¼š**

1. å¹¿åº¦ä¼˜å…ˆ(é˜Ÿåˆ—å®ç°)

   æ—¶é—´å¤æ‚åº¦O(n)

2. æ·±åº¦ä¼˜å…ˆ(æ ˆå®ç°)

   æ—¶é—´å¤æ‚åº¦O(n)

```java
// bfs Breadth First Search
   public static List<List<Integer>> bsfLeverOrder(MyTreeNode<Integer> myTreeNode) {
        List<List<Integer>> list = new ArrayList<>();

        Queue<MyTreeNode> queue = new LinkedList();
        queue.offer(myTreeNode);

        while (queue.size() > 0) {
            List<Integer> valueList = new ArrayList<>();
            int levelSize = queue.size();

            for (int i = 0; i < levelSize; i++) {
                MyTreeNode node = queue.poll();
                valueList.add((int) node.data);

                if (node.leftChild != null) {
                    queue.offer(node.leftChild);
                }
                if (node.rightChild != null) {
                    queue.offer(node.rightChild);
                }
            }

            list.add(valueList);
        }

        return list;
    }
// dfs Depth-First-Search
public static List<List<Integer>> dsfLeverOrder(MyTreeNode<Integer> myTreeNode) {
        List<List<Integer>> res = new ArrayList<>();
        if (myTreeNode != null) {
            dfs(res, myTreeNode, 0);
        }
        return res;
    }

    private static void dfs(List<List<Integer>> res, MyTreeNode node, int level) {
        if (res.size() - 1 < level) {
            res.add(new ArrayList<>());
        }
        res.get(level).add((int) node.data);
        if (node.leftChild != null) {
            dfs(res, node.leftChild, level + 1);
        }
        if (node.rightChild != null) {
            dfs(res, node.rightChild, level + 1);
        }
    }
```

##### 5. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦å’Œæœ€å°æ·±åº¦

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)**

**æ€è·¯ï¼š**

1. åˆ©ç”¨BFSæˆ–DFSå®ç°

   æŒ‰å±‚éå†æ— å¶å­èŠ‚ç‚¹æ˜¯æœ€å°æ·±åº¦ï¼Œéå†å¤§æœ€å¤§å±‚æ•°æ˜¯æœ€å¤§æ·±åº¦ã€‚


##### 6. å¯¹ç§°çš„äºŒå‰æ ‘

[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

**æ€è·¯ï¼š**

1. åˆ©ç”¨æ ˆæˆ–é˜Ÿåˆ—ï¼Œä¸€æ¬¡æ¯”è¾ƒå¯¹ç§°çš„ä¸¤ä¸ªå€¼ã€‚
2. é€’å½’



#### å…­ã€ç»å…¸æ€æƒ³

##### 1. é€’å½’å’Œåˆ†æ²»

â€‹	é€’å½’ï¼šä¸æ–­è°ƒç”¨è‡ªèº«å‡½æ•°ï¼Œä¸€å±‚ä¸€å±‚æ·±å…¥ç›´åˆ°ç»ˆæ­¢æ¡ä»¶ï¼Œç„¶åä»åº•å±‚å°†ç»“æœä¸€å±‚ä¸€å±‚è¿”å›ã€‚

â€‹	demo: nçš„é˜¶ä¹˜ï¼Œæ–æ³¢æ‹‰å¥‘ç®—æ³•ã€‚

â€‹	åˆ†æ²»ï¼šå°†å¤§é—®é¢˜åˆ†ä¸ºä¸€ä¸ªä¸ªä¸ç›¸å¹²çš„å°é—®é¢˜ï¼Œç„¶åå†ä¸€æ¬¡æ¬¡åˆå¹¶ã€‚

â€‹	demo: æ’åºç®—æ³•ã€‚

##### 2. å¹¿åº¦ä¼˜å…ˆæœç´¢å’Œæ·±åº¦ä¼˜å…ˆæœç´¢

BFS: æŒ‰å±‚æœç´¢ï¼Œäººè„‘æ€ç»´ï¼›

DFS:ç«–å‘æœç´¢ï¼Œç„¶ååå‘æŸ¥æ‰¾æ¼ç½‘ä¹‹é±¼ï¼Œç»§ç»­ç«–å‘æœç´¢ï¼Œç”µè„‘é€’å½’æ€ç»´ã€‚

<img src="images/tree_bfs_dfs.png" style="zoom:30%;" />

##### 3. è´ªå¿ƒç®—æ³•

â€‹	Greedyï¼šåœ¨å¯¹é—®é¢˜æ±‚è§£æ—¶ï¼Œæ€»æ˜¯åšå‡ºåœ¨å½“å‰çœ‹æ¥æœ€å¥½çš„é€‰æ‹©(ç›®å…‰çŸ­æµ…ï¼Œå½“å‰æœ€ä¼˜ï¼Œç»“æœä¸ä¸€å®šæœ€ä¼˜)ã€‚

â€‹	ä½¿ç”¨åœºæ™¯ï¼šç®€å•åœ°è¯´ï¼Œé—®é¢˜èƒ½å¤Ÿåˆ†è§£æˆå­é—®é¢˜è§£å†³ï¼Œ**å­é—®é¢˜çš„æœ€ä¼˜è§£èƒ½é€’æ¨å‡ºæœ€ç»ˆé—®é¢˜çš„æœ€ä¼˜è§£**ã€‚

   è¯´æ˜ï¼š

â€‹		è´ªå¿ƒç®—æ³•ä¸åŠ¨æ€è§„åˆ’çš„ä¸åŒåœ¨äºå®ƒå¯¹æ¯ä¸ªå­é—®é¢˜çš„è§£å†³æ–¹æ¡ˆéƒ½åšå‡ºé€‰æ‹©ï¼Œä¸èƒ½å›é€€ã€‚ åŠ¨æ€è§„åˆ’åˆ™ä¼šä¿å­˜ä»¥å‰çš„è¿ç®—ç»“æœï¼Œå¹¶ä¸”æ ¹æ®ä»¥å‰çš„ç»“æœå¯¹å½“å‰å°±è¡Œé€‰æ‹©ï¼Œæœ‰å›é€€åŠŸèƒ½ã€‚

##### 4. åŠ¨æ€è§„åˆ’DP

1. é€’å½’ + è®°å¿†åŒ– -> é€’æ¨ã€‚
2. çŠ¶æ€çš„å®šä¹‰ï¼šopt[n],dp[n],fib[n]ã€‚
3. çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šopt[n] = best_of(opt(n-1),opt(n-2),...)ã€‚
4. æœ€ä¼˜å­ç»“æ„ã€‚

- æ–æ³¢æ‹‰å¥‘-é€’æ¨

  æ­£å¸¸æ–æ³¢æ‹‰å¥‘æ—¶é—´å¤æ‚åº¦ä¸ºO(2~N)æ¬¡æ–¹ã€‚é‡Œé¢ç”¨è®¸å¤šé‡å¤è®¡ç®—ï¼Œå¦‚æœåŠ ä¸Šç¼“å­˜è®°å¿†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚

  <img src="images/dp_fib.png" style="zoom:50%;" />

  ç„¶åä»ä¸‹å¾€ä¸Šå€’è½¬å›å»ï¼Œç”¨åŠ¨æ€è§„åˆ’è®¡ç®—å¦‚ä¸‹**(ä»é€’å½’åº•å±‚å¼€å§‹å€’ç€æ¨å¯¼)**ï¼š

  ```java
  é€’å½’ + è®°å¿†åŒ– ==> é€’æ¨ (åŠ¨æ€è§„åˆ’çš„æ€è·¯)
  é€’æ¨å…¬å¼ï¼šF(n) = F(n-1) + F(n-2)
  
    F[0] = 0, F[1] = 1;
  	for(int i = 2; i <= n; i++){
      F[i] = F[i-1] + F[i-2];
    }
  ```

  

- æœ€ä¼˜è·¯çº¿-é€’æ¨

  è®¡ç®—ä»å¼€å§‹èµ°åˆ°ç»“æŸçš„è·¯çº¿æ€»æ•°(é€’å½’å®ç°å’Œä¸Šé¢ä¸€æ ·ï¼Œæœ‰å¤§é‡é‡å¤è®¡ç®—)ã€‚

  é€’æ¨å…¬å¼ï¼šopt[i,j] = opt[i-1,j] + opt[i,j-1]ã€‚**è¿˜æ˜¯å€’ç€æ¨ç»“æœï¼Œåé¢ç»“æœå½¢æˆå‰é¢æ•°æ®ï¼Œå³æ¯ä¸€ä¸ªçš„ç»“æœæ˜¯ä¸‹æ–¹æ–¹æ ¼å’Œå³æ–¹æ–¹æ ¼è·¯çº¿æ•°ç›®çš„æ€»å’Œï¼**

  <img src="images/dp_count_the_paths.png" style="zoom:50%;" />

- **DP VS å›æº¯ VS è´ªå¿ƒ**
  1. å›æº¯(é€’å½’) - é‡å¤è®¡ç®—
  2. è´ªå¿ƒ - æ°¸è¿œå±€éƒ¨æœ€ä¼˜
  3. DP - è®°å½•å±€éƒ¨æœ€ä¼˜å­ç»“æ„/å¤šç§è®°å½•å€¼

##### 5. LRU Cache ç¼“å­˜æœºåˆ¶

â€‹	[ç®—æ³•å‚è€ƒ](https://en.wikipedia.org/wiki/Cache_replacement_policies)

â€‹	Least recently used(æœ€è¿‘æœ€å°‘ä½¿ç”¨)ï¼Œä¸€èˆ¬ç”¨åŒå‘é“¾è¡¨å®ç°ï¼ŒO(1)å¤æ‚åº¦çš„æŸ¥è¯¢å’Œæ›´æ–°ã€‚

â€‹	LFU- Least frequently used(æœ€è¿‘æœ€ä¸å¸¸ç”¨ç®—æ³•)

<img src="images/LRU_cache.png" style="zoom:50%;" />

<img src="images/LFU_cache.png" style="zoom:50%;" />

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/lru-cache/)**

**æ€è·¯ï¼š**

1. åˆ©ç”¨åŒå‘é“¾è¡¨å’Œå“ˆå¸Œè¡¨å®ç°(ç±»ä¼¼äºç³»ç»Ÿä¸­LinkedHashMapé›†åˆ)ã€‚

```java
public class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ç§»åˆ°å¤´éƒ¨
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // å¦‚æœ key ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹
            DLinkedNode newNode = new DLinkedNode(key, value);
            // æ·»åŠ è¿›å“ˆå¸Œè¡¨
            cache.put(key, newNode);
            // æ·»åŠ è‡³åŒå‘é“¾è¡¨çš„å¤´éƒ¨
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // å¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹
                DLinkedNode tail = removeTail();
                // åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹
                cache.remove(tail.key);
                --size;
            }
        }
        else {
            // å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ä¿®æ”¹ valueï¼Œå¹¶ç§»åˆ°å¤´éƒ¨
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```



#### ä¸ƒã€å…¶ä»–

##### 1.  æ—‹è½¬æ•°ç»„

**[é¢˜ç›®å†…å®¹](https://leetcode-cn.com/problems/rotate-array/)**

**æ€è·¯ï¼š**

1. æš´åŠ›å¾ªç¯ä¾æ¬¡ç§»åŠ¨

   æ—¶é—´å¤æ‚åº¦O(N*K),ç©ºé—´å¤æ‚åº¦O(1)ã€‚

2. ä½¿ç”¨é¢å¤–æ•°ç»„

   æ—¶é—´å¤æ‚åº¦O(n),ç©ºé—´å¤æ‚åº¦O(n)ã€‚

3. ä½¿ç”¨ç¯çŠ¶æ›¿æ¢(éš¾)

   æ—¶é—´å¤æ‚åº¦O(n),ç©ºé—´å¤æ‚åº¦O(1)ã€‚

4. ä¸‰æ¬¡åè½¬

   æ—¶é—´å¤æ‚åº¦O(n),ç©ºé—´å¤æ‚åº¦O(1)ã€‚

```java
// æš´åŠ›ç§»åŠ¨
    public static void rotateSimple(int[] nums, int k) {
        for (int i = 0; i < k; i++) {
            int endValue = nums[nums.length - 1];

            for (int j = nums.length - 1 - 1; j >= 0; j--) {
                nums[j + 1] = nums[j];
            }
            nums[0] = endValue;
        }
    }
// ä¸‰æ¬¡åè½¬
  public void rotate(int[] nums, int k) {
        k = k%nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
```



##### 2.  ä¹°å–è‚¡ç¥¨æœ€ä½³æ—¶æœº

**[é¢˜ç›®å†…å®¹(æœ€å¤§ä¹°å–Kæ¬¡)121/122/123/309/188/714](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)**

**æ€è·¯ï¼š**

1. æš´åŠ›ç ´è§£

2. åŠ¨æ€è§„åˆ’

   DPå®šä¹‰å¤šç»´æ•°ç»„çŠ¶æ€ï¼Œå€’æ¨ç»“æœã€‚

```java
// æœ€ä¼˜è‚¡ç¥¨(ä¸é™äº¤æ˜“æ¬¡æ•°)
    public static int maxProfit(int[] prices){
        int[][] dp = new int[prices.length][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i=1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }

        return dp[prices.length-1][0];
    }
    // æœ€ä¼˜è‚¡ç¥¨(éåŠ¨æ€è§„åˆ’ï¼Œäº¤æ˜“1æ¬¡)
    public static int maxProfitNew(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
```









- å‚è€ƒ

[1. leetcode](https://leetcode-cn.com/problemset/lcof/)

[2. big-O](https://www.bigocheatsheet.com/)