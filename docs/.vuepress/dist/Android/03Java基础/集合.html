<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>集合 | 知鱼之乐@Android</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="Just playing around 1">
    
    <link rel="preload" href="/assets/css/0.styles.fab77d47.css" as="style"><link rel="preload" href="/assets/js/app.72ff6aaf.js" as="script"><link rel="preload" href="/assets/js/2.c485b593.js" as="script"><link rel="preload" href="/assets/js/31.1496846e.js" as="script"><link rel="prefetch" href="/assets/js/10.284a1fb6.js"><link rel="prefetch" href="/assets/js/100.e2a43098.js"><link rel="prefetch" href="/assets/js/101.f6baf967.js"><link rel="prefetch" href="/assets/js/102.4defd700.js"><link rel="prefetch" href="/assets/js/103.1ff27551.js"><link rel="prefetch" href="/assets/js/104.3823dc71.js"><link rel="prefetch" href="/assets/js/105.9bf4cd86.js"><link rel="prefetch" href="/assets/js/106.12ec8861.js"><link rel="prefetch" href="/assets/js/107.6d75a21a.js"><link rel="prefetch" href="/assets/js/108.603fe90f.js"><link rel="prefetch" href="/assets/js/109.2e145924.js"><link rel="prefetch" href="/assets/js/11.e798c60c.js"><link rel="prefetch" href="/assets/js/110.4279c5fe.js"><link rel="prefetch" href="/assets/js/111.859c95ab.js"><link rel="prefetch" href="/assets/js/112.a6705b4c.js"><link rel="prefetch" href="/assets/js/12.8595f619.js"><link rel="prefetch" href="/assets/js/13.e2df1669.js"><link rel="prefetch" href="/assets/js/14.c1715815.js"><link rel="prefetch" href="/assets/js/15.4ba71b7a.js"><link rel="prefetch" href="/assets/js/16.f37b9e9b.js"><link rel="prefetch" href="/assets/js/17.a60327d6.js"><link rel="prefetch" href="/assets/js/18.53c04c0a.js"><link rel="prefetch" href="/assets/js/19.053bc998.js"><link rel="prefetch" href="/assets/js/20.3977e068.js"><link rel="prefetch" href="/assets/js/21.58972de6.js"><link rel="prefetch" href="/assets/js/22.9e4f6d2c.js"><link rel="prefetch" href="/assets/js/23.af033bc4.js"><link rel="prefetch" href="/assets/js/24.dca728d0.js"><link rel="prefetch" href="/assets/js/25.804075ff.js"><link rel="prefetch" href="/assets/js/26.7f0d92c6.js"><link rel="prefetch" href="/assets/js/27.7061ef4f.js"><link rel="prefetch" href="/assets/js/28.5d3fbad1.js"><link rel="prefetch" href="/assets/js/29.88251a71.js"><link rel="prefetch" href="/assets/js/3.e07f21a9.js"><link rel="prefetch" href="/assets/js/30.5b205371.js"><link rel="prefetch" href="/assets/js/32.f31faa5b.js"><link rel="prefetch" href="/assets/js/33.b6f40a9c.js"><link rel="prefetch" href="/assets/js/34.b7426d6b.js"><link rel="prefetch" href="/assets/js/35.fd1b070b.js"><link rel="prefetch" href="/assets/js/36.c462a2bb.js"><link rel="prefetch" href="/assets/js/37.c00c82e3.js"><link rel="prefetch" href="/assets/js/38.ef67e5ac.js"><link rel="prefetch" href="/assets/js/39.284aa998.js"><link rel="prefetch" href="/assets/js/4.9b89f070.js"><link rel="prefetch" href="/assets/js/40.e5f9fa54.js"><link rel="prefetch" href="/assets/js/41.ad9935d2.js"><link rel="prefetch" href="/assets/js/42.a5894d33.js"><link rel="prefetch" href="/assets/js/43.7bdfd57e.js"><link rel="prefetch" href="/assets/js/44.78fad530.js"><link rel="prefetch" href="/assets/js/45.f190392d.js"><link rel="prefetch" href="/assets/js/46.83d4716b.js"><link rel="prefetch" href="/assets/js/47.a66e1c3c.js"><link rel="prefetch" href="/assets/js/48.3f0732b3.js"><link rel="prefetch" href="/assets/js/49.e2fbcfc6.js"><link rel="prefetch" href="/assets/js/5.726d428a.js"><link rel="prefetch" href="/assets/js/50.d045bff8.js"><link rel="prefetch" href="/assets/js/51.0deb7576.js"><link rel="prefetch" href="/assets/js/52.9efcf98a.js"><link rel="prefetch" href="/assets/js/53.66f14271.js"><link rel="prefetch" href="/assets/js/54.45d67d8f.js"><link rel="prefetch" href="/assets/js/55.ef6915bf.js"><link rel="prefetch" href="/assets/js/56.3f885310.js"><link rel="prefetch" href="/assets/js/57.c0c28d8e.js"><link rel="prefetch" href="/assets/js/58.6f0766a3.js"><link rel="prefetch" href="/assets/js/59.81596e96.js"><link rel="prefetch" href="/assets/js/6.7aaff1b3.js"><link rel="prefetch" href="/assets/js/60.b323e54e.js"><link rel="prefetch" href="/assets/js/61.182aca2f.js"><link rel="prefetch" href="/assets/js/62.2080a8a5.js"><link rel="prefetch" href="/assets/js/63.3027d9ab.js"><link rel="prefetch" href="/assets/js/64.427a271f.js"><link rel="prefetch" href="/assets/js/65.8ca9b031.js"><link rel="prefetch" href="/assets/js/66.7484cfe7.js"><link rel="prefetch" href="/assets/js/67.3430d619.js"><link rel="prefetch" href="/assets/js/68.2dbef16a.js"><link rel="prefetch" href="/assets/js/69.f1560f6c.js"><link rel="prefetch" href="/assets/js/7.c35f8860.js"><link rel="prefetch" href="/assets/js/70.66c08c04.js"><link rel="prefetch" href="/assets/js/71.ee2124da.js"><link rel="prefetch" href="/assets/js/72.277e570b.js"><link rel="prefetch" href="/assets/js/73.95adb7a4.js"><link rel="prefetch" href="/assets/js/74.1926c49c.js"><link rel="prefetch" href="/assets/js/75.ff82ab13.js"><link rel="prefetch" href="/assets/js/76.418b3c51.js"><link rel="prefetch" href="/assets/js/77.cb7989bf.js"><link rel="prefetch" href="/assets/js/78.a1f4f7e4.js"><link rel="prefetch" href="/assets/js/79.bc54dab3.js"><link rel="prefetch" href="/assets/js/8.69c9d61d.js"><link rel="prefetch" href="/assets/js/80.f4a6e9af.js"><link rel="prefetch" href="/assets/js/81.9044348b.js"><link rel="prefetch" href="/assets/js/82.2ef71a06.js"><link rel="prefetch" href="/assets/js/83.7502adeb.js"><link rel="prefetch" href="/assets/js/84.ba9fa20e.js"><link rel="prefetch" href="/assets/js/85.6cd87159.js"><link rel="prefetch" href="/assets/js/86.108383f8.js"><link rel="prefetch" href="/assets/js/87.db17d86d.js"><link rel="prefetch" href="/assets/js/88.43b24a0f.js"><link rel="prefetch" href="/assets/js/89.5bd2a4ab.js"><link rel="prefetch" href="/assets/js/9.24cdaf82.js"><link rel="prefetch" href="/assets/js/90.31ab1ddc.js"><link rel="prefetch" href="/assets/js/91.a6815e54.js"><link rel="prefetch" href="/assets/js/92.91b03203.js"><link rel="prefetch" href="/assets/js/93.0cbd404f.js"><link rel="prefetch" href="/assets/js/94.2e3b0267.js"><link rel="prefetch" href="/assets/js/95.617b4408.js"><link rel="prefetch" href="/assets/js/96.aa9c23a3.js"><link rel="prefetch" href="/assets/js/97.75590d85.js"><link rel="prefetch" href="/assets/js/98.b813a897.js"><link rel="prefetch" href="/assets/js/99.d97bad55.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fab77d47.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">知鱼之乐@Android</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Android基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Android/01基础机制/1.Android系统启动流程.html" class="sidebar-link">Android系统启动过程</a></li><li><a href="/Android/01基础机制/2.Binder进程通信机制.html" class="sidebar-link">Binder进程通信机制</a></li><li><a href="/Android/07面试题/1.面试题-计算机基础.html" class="sidebar-link">1面试题-计算机基础</a></li><li><a href="/Android/07面试题/2.面试题-Android.html" class="sidebar-link">2面试题-Android</a></li><li><a href="/Android/07面试题/3.面试题-架构设计.html" class="sidebar-link">3面试题-架构设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>业务功能</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/业务功能设计/1.设计流畅的图片展示.html" class="sidebar-link">多图片显示</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Tools</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Tools/1.Mac开发快捷键大全.html" class="sidebar-link">Mac开发快捷键大全</a></li><li><a href="/Tools/2.翻墙工具指南.html" class="sidebar-link">翻墙工具指南</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h3> <p>[TOC]</p> <h4 id="_1-java集合框架"><a href="#_1-java集合框架" class="header-anchor">#</a> 1. Java集合框架？</h4> <h5 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h5> <ul><li><p>Map、Collection接口是所有集合框架的父类接口。</p></li> <li><p>Collection接口的子接口包括：Set和List接口；</p></li> <li><p>Map(<strong>kv</strong>)接口的实现类主要有：HashMap、TreeMap、HashTable、ConcurrentHashMap以及Propreties等。</p></li> <li><p>List(<strong>有序可重复</strong>)接口的实现类主要有：ArrayList、LinkedList、Vetor、Stack等。</p></li> <li><p>Set(<strong>不可重复</strong>)接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等。</p> <img src="images/java集合.png" alt="java集合" style="zoom:40%;"></li></ul> <h4 id="_2-hashmap原理"><a href="#_2-hashmap原理" class="header-anchor">#</a> 2. HashMap原理？</h4> <h5 id="存储结构"><a href="#存储结构" class="header-anchor">#</a> 存储结构</h5> <p>​	采用<strong>链表散列</strong>的数据结构，即数组和链表组成的，当链表长度大于8，采用红黑树存储。</p> <p>​	注意：初始容量为16，扩容方式为2N。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * HashMap数据结构
 * &quot;链表散列&quot;的数据结构，内部实现是一个桶数组，每个桶中存放着一个单链表的头结点。
 *  链表长度大于8，采用红黑树存储。
 */</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>  <span class="token comment">// 默认负载因子！</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// aka 16   默认容量！</span>

 <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span> <span class="token comment">// extned Entry&lt;K,V&gt;</span>
 <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
 <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>			<span class="token comment">// 阈值 table.size * loadFactor</span>
 <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>

 <span class="token comment">// 计算hash</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 获得key索引</span>
 tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>tableSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">;</span>

 <span class="token comment">// 大于阈值后，2倍扩容</span>
 newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>
</code></pre></div><h5 id="常见问题"><a href="#常见问题" class="header-anchor">#</a> 常见问题</h5> <ol><li><p>putVal逻辑？</p> <p><img src="images/hashmap_put%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="put"></p></li> <li><p>为什么要自己计算hash?</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
  			<span class="token comment">// 把高16位和低16位做异或运算，更好保留高位数特征。避免后面计算index时，高位数没有参与运算。</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>为了让key的高低位数据都参与运算，防止计算槽位是丢失高位特征。</p> <p><a href="https://www.cnblogs.com/zxporz/p/11204233.html" target="_blank" rel="noopener noreferrer">参考！！<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>为什么容量总是2的次幂？</p> <ul><li>为了让哈希后的结果更加均匀</li> <li>当n为2次幂时，满足公式：<code>(n - 1) &amp; hash = hash % n</code>，与运算效率更高。</li></ul> <p>索引位置计算公式： <code>tab[(n - 1) &amp; hash]</code>。</p> <p>因为 n 永远是2的次幂，所以 n-1 通过 二进制表示，永远都是尾端以连续1的形式表示（00001111，00000011）。当(n - 1) 和 hash 做与运算时，会保留hash中 后 x 位的 1(且索引合法)，
例如 00001111 &amp; 10000011 = 00000011</p> <p>好处：</p> <ul><li>&amp;(与)运算符比%(取模)运算速度快；</li> <li>能保证索引值不会超出长度；</li> <li>当n为2次幂时，满足公式：<code>(n - 1) &amp; hash = hash % n</code></li></ul> <p><strong>说了这么多点，上面提到的所有问题，最终目的还是为了让哈希后的结果更均匀的分部，减少哈希碰撞，提升hashmap的运行效率。</strong></p></li> <li><p>为什么hash计算公式是<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>?</p> <p>实质上是把一个数的低16位和高16位做异或运算，因为前面计算索引公式，只有hash的低x位参与到运算。使高16位也参到hash的运算能减少hash冲突。</p></li> <li><p>为什么默认加载引子选择0.75？</p> <p><strong>提高空间利用率和减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小。</strong></p> <p>加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；</p> <p>加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数。</p></li> <li><p>HashMap扩容机制<code>resize()</code>？</p> <ul><li><p>Bucket 只有一个Node，重新计算位置；</p></li> <li><p>Buket是Node链表，循环遍历，采用高低位链进行扩容；</p> <p><strong>通过e.hash &amp; oldCap来判断节点位置通过再次hash算法后，是否会发生改变，如果为0表示不会发生改变(newIndex = oldIndex)，如果为1表示会发生改变(newIndex = oldIndex+oldCap)。</strong></p> <p>遍历链表添加，通过计算位置添加。</p></li> <li><p>Buket是TreeNode，采用红黑树挪移元素；</p></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/**构造新表，初始化表中数据*/</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//将刚创建的新表赋值给table</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//遍历将原来table中的数据放到扩容后的新表中来</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">//1. 没有链表Node节点，直接放到新的table中下标为【e.hash &amp; (newCap - 1)】位置即可</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token comment">//2. 如果是treeNode节点，则树上的节点放到newTab中</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//3. 如果e后面还有链表节点，则遍历e所在的链表，</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 保证顺序</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">{</span>
                        <span class="token comment">//记录下一个节点</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token comment">/**
                         * newTab的容量是以前旧表容量的两倍,因为数组table下标并不是根据循环逐步递增
                         * 的，而是通过（table.length-1）&amp; hash计算得到，因此扩容后，存放的位置就
                         * 可能发生变化，那么到底发生怎样的变化呢，就是由下面的算法得到.
                         *
                         * 通过e.hash &amp; oldCap来判断节点位置通过再次hash算法后，是否会发生改变，如
                         * 果为0表示不会发生改变，如果为1表示会发生改变。到底怎么理解呢，举个例子：
                         * e.hash = 13 二进制：0000 1101
                         * oldCap = 32 二进制：0001 0000
                         *  &amp;运算：  0  二进制：0000 0000
                         * 结论：元素位置在扩容后不会发生改变
                         */</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token comment">/**
                         * e.hash = 18 二进制：0001 0010
                         * oldCap = 16 二进制：0001 0000
                         * &amp;运算：  16 二进制：0001 0000
                         * 结论：元素位置在扩容后会发生改变，那么如何改变呢？
                         * newCap = 32 二进制：0010 0000
                         * 通过(newCap-1)&amp;hash
                         * 即0001 1111 &amp; 0001 0010 得0001 0010，32+2 = 18
                         */</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token comment">/**
                         * 若(e.hash &amp; oldCap) == 0，下标不变，将原表某个下标的元素放到扩容表同样
                         * 下标的位置上
                         */</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token comment">/**
                         * 若(e.hash &amp; oldCap) != 0，将原表某个下标的元素放到扩容表中
                         * [下标+增加的扩容量]的位置上 !!!
                         */</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>HashMap在JDK1.7和1.8中区别？</p> <table><thead><tr><th>不同</th> <th>JDK1.7</th> <th>JDK1.8</th></tr></thead> <tbody><tr><td>存储结构</td> <td>数组+链表</td> <td>数组+链表+红黑树</td></tr> <tr><td>初始化方式</td> <td>单独函数：<code>inflateTable()</code></td> <td>直接集成到了扩容函数<code>resize()</code>中</td></tr> <tr><td>hash值计算方式</td> <td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td> <td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr> <tr><td>存放数据的规则</td> <td>无冲突时，存放数组；冲突时，存放链表</td> <td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr> <tr><td>插入数据方式</td> <td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td> <td>尾插法（直接插入到链表尾部/红黑树）</td></tr> <tr><td>扩容后存储位置的计算方式</td> <td><strong>全部按照原来方法进行计算</strong>（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td> <td>按照扩容后的规律计算（即扩容后的位置=<strong>原位置 or 原位置 + 旧容量</strong>）</td></tr></tbody></table></li> <li><p>HashMap如何解决hash冲突？</p> <ul><li><p>链表法(目前使用)</p></li> <li><p>开放寻址法</p> <p>核心思想：如果出现冲突，重新探测一个空闲位置，再将元素插入。</p> <ol><li><p>线性探测法；</p> <p>往后逐个或n个一次查找空闲位置存储；</p></li> <li><p>线性补偿探测法：</p> <p>如果冲突，根据规则重新生成一个新的hash值。</p></li></ol> <p>缺点：1.容易造成堆聚现象，添加元素越多，堆聚现象越严重。</p> <p>​      2.删除元素特别困难，当位置为空时，无法判断元素的位置</p></li> <li><p>双重散列法</p> <p>假设第二个散列函数值为T
- 线性探测法：逐个检查冲突位置的下一个位置
- 双重散列表：每隔T个位置检查一次</p></li> <li><p>建立公共溢出区域</p></li></ul></li></ol> <h4 id="_3-hashmap和hashtable区别"><a href="#_3-hashmap和hashtable区别" class="header-anchor">#</a> 3. hashmap和hashtable区别？</h4> <ol><li>HashTable是线程安全的；</li> <li>HashTable不允许K/V为null;</li> <li>HashMap继承自AbstractMap类，而HashTable继承自Dictionary类;</li> <li>hash计算方式不同，hashmap自己计算，hashtable直接使用hashCode()函数值；</li> <li>计算索引方式不同(hashmap效率更高，但必须是2容量必须为2的幂)，<code>index = (n - 1) &amp; hash</code>和<code>(hash &amp; 0x7FFFFFFF) % tab.length</code>;</li> <li>扩容方式不同： 默认容量 16、11，扩容2n,2n+1;</li> <li>存储方式不同，hashtable只用链表存储，hashmap大于8后使用红黑树存储。</li></ol> <h4 id="_4-concurrenthashmap和hashtable的区别"><a href="#_4-concurrenthashmap和hashtable的区别" class="header-anchor">#</a> 4. ConcurrentHashMap和HashTable的区别？</h4> <p>​	ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p> <p>​	在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。</strong></p> <h4 id="_5-hashset如何保证数据不可重复的"><a href="#_5-hashset如何保证数据不可重复的" class="header-anchor">#</a> 5. HashSet如何保证数据不可重复的？</h4> <p>底层使用HashMap存储，数值存储在HashMap的key中，key本身就不允许重复。</p> <h4 id="_6-array和arraylist的区别"><a href="#_6-array和arraylist的区别" class="header-anchor">#</a> 6. Array和ArrayList的区别？</h4> <ol><li>Array中可以包含基本类型和对象类型，ArrayList中只能包含对象类型；</li> <li>Array大小固定，ArrayList支持动态变化；</li></ol> <h4 id="_7-arraylist和linkedlist的区别"><a href="#_7-arraylist和linkedlist的区别" class="header-anchor">#</a> 7. ArrayList和LinkedList的区别？</h4> <ol><li>LinkedList实现了List和Deque接口，一般称双向链表。ArrayList实现了List接口，动态数组；</li> <li>LinkedList在插入或删除数据时更加高效，ArrayList在查找时更加高效；</li> <li>LinkedList比ArrayList需要更多的内存。</li></ol> <h4 id="_8-arraylist和vector的区别"><a href="#_8-arraylist和vector的区别" class="header-anchor">#</a> 8. ArrayList和Vector的区别？</h4> <ol><li>都是基于数组实现，扩从使用<code>Arrays.copyOf(original,newLength)</code>;</li> <li>Vector是线程安全的；</li> <li>ArrayList 每次扩容1.5倍；Vector每次扩容2倍。</li></ol> <h4 id="_9-string、stringbuffer、stringbuilder区别"><a href="#_9-string、stringbuffer、stringbuilder区别" class="header-anchor">#</a> 9. String、StringBuffer、StringBuilder区别？</h4> <ol><li><p>String 适合存储常量，不易频繁修改；</p></li> <li><p>StringBuffer 适合存储可变数据，线程安全；</p></li> <li><p>StringBulider 适合存储可变数据，执行效率高于StringBuffer，非线程安全,单线程场景使用；</p> <p>执行效率： StringBuilder &lt; StringBuffer &lt; String &lt; +.</p></li></ol> <h4 id="_10-equals、-和hashcode的区别"><a href="#_10-equals、-和hashcode的区别" class="header-anchor">#</a> 10. equals、==和hashcode的区别？</h4> <ul><li><p>区别</p> <ol><li><p>==   基本数据类型，比较的是它们的<code>值</code>；引用类型，比较的是<code>内存地址</code>,即同一个对象才为true;</p></li> <li><p>equals  默认比较的是<code>内存地址</code>，String类型默认比较的是字符串内容; 如果类覆盖了equals方法，那就根据代码进行比较。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Object类默认equals方法，比较内存地址
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * String类equals方法，比较字符串每个字符是否相等
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    i<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">/**
 * Integer类equals方法，比较数值相等
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> value <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>hashcode</p> <blockquote><p>在集合中添加新元素是，通过hashcode比较，大大减少需要equals次数。还可以提升查找效率。</p> <p>将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。</p></blockquote> <p>1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。
2、如果两个对象不equals，他们的hashcode有可能相等。
3、如果两个对象hashcode相等，他们不一定equals。
4、如果两个对象hashcode不相等，他们一定不equals。</p></li></ol></li> <li><p>涉及知识点</p> <ol><li><p>比较结果</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token comment">// 例如</span>
 <span class="token class-name">Integer</span> a1 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>  <span class="token comment">// java在编译的时候,被翻译成-&gt; Integer b1 = Integer.valueOf(127);</span>
 <span class="token class-name">Integer</span> b1 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
 <span class="token class-name">Integer</span> s1 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
 <span class="token class-name">Integer</span> s2 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;a1==b1&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a1<span class="token operator">==</span>b1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true  ？</span>
 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;s1==s2&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
 <span class="token comment">/**
 * 看一下源码大家都会明白，对于-128到127之间的数，会进行缓存。
 */</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
         <span class="token keyword">assert</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high <span class="token operator">&gt;=</span> <span class="token number">127</span><span class="token punctuation">;</span>  
         <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>  
             <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
     <span class="token punctuation">}</span>  

</code></pre></div></li> <li><p>int和integer比较时候，integer会自动拆箱为int.</p></li> <li><p>为什么覆盖equals时总要覆盖hashcode方法？</p> <p>会违反Object.hashcode的通俗约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</p></li></ol></li></ul> <h4 id="_11-hashset、linkedhashset、treeset区别"><a href="#_11-hashset、linkedhashset、treeset区别" class="header-anchor">#</a> 11. HashSet、LinkedHashSet、TreeSet区别？</h4> <ul><li><p>数据结构</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * HashSet数据结构
 * 1. 基于HashMap实现，key存数据，value存统一个空对象；
 * 2. 存储唯一、无序的对象；
 * 3. 非线程安全；
 * 4. 可以存储一个null;
 */</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>
<span class="token comment">// Dummy value to associate with an Object in the backing Map</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * TreeSet数据结构
 * 1. 基于TreeMap实现，key存数据，value存统一个空对象；
 * 2. 存储元素唯一、有序的对象；
 * 3. 非线程安全；
 * 4. 不可存储null;
 */</span>
 <span class="token keyword">public</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
 <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * LinkedHashSet数据结构
 * 1. 继承自HashSet，基于LinkedHashMap实现；区别是：插入或遍历对象顺序一致；
 */</span>
<span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dummy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre></div></li> <li><p>使用场景</p> <ol><li><p>三者都实现Set接口，特性是元素唯一；</p></li> <li><p>HashSet 查询速度快，用HashTable实现，它的元素是无序的；</p> <p>LinkedHashSet 继承HashSet,用LinkedHashMap实现，它的元素是有序的；</p> <p>TreeSet  底层实现是红黑树(自平衡二叉树)，可以对数据进行排序；不但能保证元素唯一，还能元素保证有序;</p></li></ol></li></ul> <h4 id="_12-arraymap原理"><a href="#_12-arraymap原理" class="header-anchor">#</a> 12. ArrayMap原理</h4> <h5 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h5> <p><a href="https://zhuanlan.zhihu.com/p/23329871?from_voters_page=true" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ArrayMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
	 <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mHashes<span class="token punctuation">;</span>    <span class="token comment">// 存储key的hash值，方便二分查找(如果碰撞，两边继续查找)</span>
   <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mArray<span class="token punctuation">;</span>  <span class="token comment">// 存放key和value值</span>
   <span class="token keyword">int</span> mSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>  
</code></pre></div><p><img src="images/%E9%9B%86%E5%90%88-arraymap.png" alt="arraymap"></p> <h5 id="作用和特点"><a href="#作用和特点" class="header-anchor">#</a> 作用和特点</h5> <p>ArrayMap是Android特有的api，用在移动端，它主要是提升内存效率；</p> <p>ArrayMap比传统的HashMap慢，所以ArrayMap不适合包含大数据的处理，因为添加和删除元素的时候需要使用二分搜索来查找元素；</p> <p>ArrayMap会在remove item的时候收缩数组；</p> <p>线程不安全的。</p> <p>它可以避免在将数据插入Map中时额外的空间消耗（对比<code>HashMap</code>）。
而且它扩容的更合适，<strong>扩容时只需要数组拷贝工作，不需要重建哈希表</strong>。</p> <h4 id="_13-sparsearray原理"><a href="#_13-sparsearray原理" class="header-anchor">#</a> 13. SparseArray原理</h4> <blockquote><p>SparseArray类似于ArrayMap,在Key为整数时可以考虑替代HashMap提供更有效的空间利用。</p> <p>使用二分查找，大数据的时候查找慢，但效率高，在千级数据量内可以取代Hashmap。</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mKeys<span class="token punctuation">;</span> <span class="token comment">// 二分查找</span>
<span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mValues<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> mSize<span class="token punctuation">;</span>

<span class="token comment">// 几种列席</span>
<span class="token class-name">SparseArray</span>          <span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span>
<span class="token class-name">LongSparseArray</span>      <span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span>
<span class="token class-name">SparseBooleanArray</span>   <span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">&gt;</span></span>
<span class="token class-name">SparseIntArray</span>       <span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">&gt;</span></span>
<span class="token class-name">SparseLongArray</span>      <span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h4 id="_14-blockingqueue-阻塞队列"><a href="#_14-blockingqueue-阻塞队列" class="header-anchor">#</a> 14. BlockingQueue(阻塞队列)？</h4> <blockquote><p>多用于并发模型，条件不足会是调用线程阻塞，满足条件后唤醒调用线程。</p> <p>put/take() 会阻塞当前线程；offer/pool()方法不阻塞。</p></blockquote> <p>分类：</p> <ul><li><p>ArrayBlockingQueue</p> <p>基于数组实现，大小固定，公用一个锁对象，意味着放入或消费无法并发运行。</p></li> <li><p>LinkedBlockingQueue</p> <p>基于链表实现，默认大小int最大值，读写锁分离，效率更高。</p></li> <li><p>DelayQueue(延迟)</p></li> <li><p>PriorityBlockingQueue(优先级)</p></li> <li><p>SynchronousQueue(无缓存队列)</p></li></ul> <h4 id="_15-treemap实现原理"><a href="#_15-treemap实现原理" class="header-anchor">#</a> 15. TreeMap实现原理</h4> <p>​	基于红黑树**（Red-Black tree）**实现。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.72ff6aaf.js" defer></script><script src="/assets/js/2.c485b593.js" defer></script><script src="/assets/js/31.1496846e.js" defer></script>
  </body>
</html>
