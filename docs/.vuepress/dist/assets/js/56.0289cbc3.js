(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{416:function(t,a,s){"use strict";s.r(a);var e=s(42),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"内存优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存优化"}},[t._v("#")]),t._v(" 内存优化")]),t._v(" "),s("p",[t._v("[TOC]")]),t._v(" "),s("blockquote",[s("p",[t._v("解决方案：")]),t._v(" "),s("ol",[s("li",[t._v("设备分级；")]),t._v(" "),s("li",[t._v("图片优化；")]),t._v(" "),s("li",[t._v("内存泄漏(LeakCanary)；")]),t._v(" "),s("li",[t._v("大对象、静态对象优化；")])])]),t._v(" "),s("h3",{attrs:{id:"一、概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、概述"}},[t._v("#")]),t._v(" 一、概述")]),t._v(" "),s("h4",{attrs:{id:"_1-手机内存和pc内存区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-手机内存和pc内存区别"}},[t._v("#")]),t._v(" 1. 手机内存和PC内存区别？")]),t._v(" "),s("p",[t._v("​\tPC内存：DDR,全名 "),s("strong",[t._v("双倍数据速率内存")]),t._v("。")]),t._v(" "),s("p",[t._v("​\t手机内存：LPDDR，全称是**“低功耗双倍数据速率内存”**，其中 LP 就是“Lower Power”低功耗的意思。")]),t._v(" "),s("p",[t._v("​\t区别：体积小、功耗小。")]),t._v(" "),s("p",[t._v("​\t以 LPDDR4 为例，带宽 = 时钟频率 × 内存总线位数 ÷ 8，即 1600 × 64 ÷ 8 = 12.8GB/s，因为是 DDR 内存是双倍速率，所以最后的带宽是 12.8 × 2 = 25.6GB/s。")]),t._v(" "),s("p",[s("img",{attrs:{src:"images/apm_memory_phone.png",alt:""}})]),t._v(" "),s("p",[t._v("目前市面上的手机，主流的运行内存有 LPDDR3、LPDDR4 以及 LPDDR4X。可以看出 LPDDR4 的性能要比 LPDDR3 高出一倍，而 LPDDR4X 相比 LPDDR4 工作电压更低，所以也比 LPDDR4 省电 20%～40%。当然图中的数据是标准数据，不同的生成厂商会有一些低频或者高频的版本，性能方面高频要好于低频。")]),t._v(" "),s("h4",{attrs:{id:"_2-设备内存大小与年限表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-设备内存大小与年限表"}},[t._v("#")]),t._v(" 2. 设备内存大小与年限表")]),t._v(" "),s("p",[t._v("其中：2010、2013位分水岭。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("RAM")]),t._v(" "),s("th",[t._v("condition")]),t._v(" "),s("th",[t._v("Year Class")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("768MB")]),t._v(" "),s("td",[t._v("1 core")]),t._v(" "),s("td",[t._v("2009")])]),t._v(" "),s("tr",[s("td"),t._v(" "),s("td",[t._v("2+ cores")]),t._v(" "),s("td",[t._v("2010")])]),t._v(" "),s("tr",[s("td",[t._v("1GB")]),t._v(" "),s("td",[t._v("<1.3GHz")]),t._v(" "),s("td",[t._v("2011")])]),t._v(" "),s("tr",[s("td"),t._v(" "),s("td",[t._v("1.3GHz+")]),t._v(" "),s("td",[t._v("2012")])]),t._v(" "),s("tr",[s("td",[t._v("1.5GB")]),t._v(" "),s("td",[t._v("<1.8GHz")]),t._v(" "),s("td",[t._v("2012")])]),t._v(" "),s("tr",[s("td"),t._v(" "),s("td",[t._v("1.8GHz+")]),t._v(" "),s("td",[t._v("2013")])]),t._v(" "),s("tr",[s("td",[t._v("2GB")]),t._v(" "),s("td"),t._v(" "),s("td",[t._v("2013")])]),t._v(" "),s("tr",[s("td",[t._v("3GB")]),t._v(" "),s("td"),t._v(" "),s("td",[t._v("2014")])]),t._v(" "),s("tr",[s("td",[t._v("5GB")]),t._v(" "),s("td"),t._v(" "),s("td",[t._v("2015")])]),t._v(" "),s("tr",[s("td",[t._v("more")]),t._v(" "),s("td"),t._v(" "),s("td",[t._v("2016")])])])]),t._v(" "),s("h4",{attrs:{id:"_3-引发问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-引发问题"}},[t._v("#")]),t._v(" 3. 引发问题")]),t._v(" "),s("ol",[s("li",[t._v("异常。比如：OOM、重启、low memory kill 杀进程。")]),t._v(" "),s("li",[t._v("卡顿。比如：GC回收频繁。")])]),t._v(" "),s("p",[s("strong",[t._v("两个误区：")])]),t._v(" "),s("p",[t._v("误区一：内存占用越少越好；")]),t._v(" "),s("p",[t._v("误区二：Native 内存不用管。")]),t._v(" "),s("h3",{attrs:{id:"二、测量方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、测量方式"}},[t._v("#")]),t._v(" 二、测量方式")]),t._v(" "),s("h4",{attrs:{id:"_1-java内存分配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-java内存分配"}},[t._v("#")]),t._v(" 1. Java内存分配")]),t._v(" "),s("p",[t._v("​\t跟踪Java堆内存使用情况，最常用的工具有Allocation Tracker 和 MAT(Memory Analyzer Tool)，一个是AS工具自带的，一个是eclipse 插件。")]),t._v(" "),s("p",[t._v("Allocation Tracker 的三个缺点。")]),t._v(" "),s("p",[t._v("​\t获取的信息过于分散，中间夹杂着不少其他的信息，很多信息不是应用申请的，可能需要进行不少查找才能定位到具体的问题。")]),t._v(" "),s("p",[t._v("​\t跟 "),s("strong",[t._v("Traceview(统计函数执行时间)")]),t._v(" 一样，无法做到自动化分析，每次都需要开发者手工开始 / 结束，这对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难。")]),t._v(" "),s("p",[t._v("​\t虽然在 Allocation Tracking 的时候，不会对手机本身的运行造成过多的性能影响，但是在停止的时候，直到把数据 dump 出来之前，经常会把手机完全卡死，如果时间过长甚至会直接 ANR。")]),t._v(" "),s("p",[t._v("​\t"),s("strong",[t._v("解决方法（困难多多）：")])]),t._v(" "),s("p",[t._v("​\t实现一个自定义的“Allocation Tracker”，实现对象内存的自动化分析。通过这个工具可以获取所有对象的申请信息（大小、类型、堆栈等），可以找到一段时间内哪些对象占用了大量的内存。")]),t._v(" "),s("h4",{attrs:{id:"_2-native内存分配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-native内存分配"}},[t._v("#")]),t._v(" 2. Native内存分配")]),t._v(" "),s("ol",[s("li",[t._v("利用Allocation Tracker工具，不太友好。\n"),s("ol",{attrs:{start:"2"}},[s("li",[t._v("利用"),s("a",{attrs:{href:"https://android.googlesource.com/platform/bionic/+/master/libc/malloc_debug/README.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Malloc 调试"),s("OutboundLink")],1),t._v("、"),s("a",{attrs:{href:"https://android.googlesource.com/platform/bionic/+/master/libc/malloc_hooks/README.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Malloc Hooks"),s("OutboundLink")],1),t._v("。")])])])]),t._v(" "),s("h3",{attrs:{id:"三、内存优化方向探讨"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、内存优化方向探讨"}},[t._v("#")]),t._v(" 三、内存优化方向探讨")]),t._v(" "),s("h4",{attrs:{id:"_1-设备分级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-设备分级"}},[t._v("#")]),t._v(" 1. 设备分级")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 动画设备分级展示")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("year "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2013")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Do advanced animation")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("year "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2010")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Do simple animation")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Phone too slow, don't do any animations")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h4",{attrs:{id:"_2-图片优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-图片优化"}},[t._v("#")]),t._v(" 2. 图片优化")]),t._v(" "),s("h4",{attrs:{id:"_3-内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存泄漏"}},[t._v("#")]),t._v(" 3. 内存泄漏")]),t._v(" "),s("h4",{attrs:{id:"_4-本地或线上内存监控"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-本地或线上内存监控"}},[t._v("#")]),t._v(" 4. 本地或线上内存监控")]),t._v(" "),s("h3",{attrs:{id:"四、leakcanary内存泄漏原理分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、leakcanary内存泄漏原理分析"}},[t._v("#")]),t._v(" 四、LeakCanary内存泄漏原理分析")]),t._v(" "),s("blockquote",[s("p",[t._v("LeakCanary如何检测内存泄漏的呢？主要分为7步:")]),t._v(" "),s("ul",[s("li",[t._v("1、"),s("code",[t._v("RefWatcher.watch()")]),t._v("创建了一个"),s("code",[t._v("KeyedWeakReference")]),t._v("用于去观察对象。")]),t._v(" "),s("li",[t._v("2、然后，在后台线程中，它会检测引用是否被清除了，并且是否没有触发GC。")]),t._v(" "),s("li",[t._v("3、如果引用仍然没有被清除，那么它将会把堆栈信息保存在文件系统中的.hprof文件里。")]),t._v(" "),s("li",[t._v("4、"),s("code",[t._v("HeapAnalyzerService")]),t._v("被开启在一个独立的进程中，并且"),s("code",[t._v("HeapAnalyzer")]),t._v("使用了"),s("code",[t._v("HAHA")]),t._v("开源库解析了指定时刻的堆栈快照文件heap dump。")]),t._v(" "),s("li",[t._v("5、从"),s("code",[t._v("heap dump")]),t._v("中，"),s("code",[t._v("HeapAnalyzer")]),t._v("根据一个独特的引用"),s("code",[t._v("key")]),t._v("找到了"),s("code",[t._v("KeyedWeakReference")]),t._v("，并且定位了泄露的引用。")]),t._v(" "),s("li",[t._v("6、"),s("code",[t._v("HeapAnalyzer")]),t._v("为了确定是否有泄露，计算了到GC Roots的最短强引用路径，然后建立了导致泄露的链式引用。")]),t._v(" "),s("li",[t._v("7、这个结果被传回到app进程中的"),s("code",[t._v("DisplayLeakService")]),t._v("，然后一个泄露通知便展现出来了。")])])]),t._v(" "),s("p",[t._v("官方原理解释是:")]),t._v(" "),s("p",[s("strong",[t._v("在一个Activity执行完onDestroy后，将它放入到WeakReference中，然后将这个WeakReference类型的Activity的对象与ReferenceQueue关联，注意: 如果一个对象要被GC回收了，会把它引用的对象放入到ReferenceQueue中。这时候只需要在ReferenceQueue中去查找是否存在该对象，如果没有就执行一个GC，再次查找，如果还是没有，则说明该对象可能无法被回收，也就可能发生了内存泄漏，最后使用HAHA这个开源库取分析dump之后的heap内存。")])]),t._v(" "),s("p",[s("strong",[t._v("测试demo：")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对象")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 引用队列，gc回收后会放入队列")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceQueue")]),t._v(" referenceQueue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceQueue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 建立弱引用")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("WeakReference")]),t._v(" weakReference "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("WeakReference")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("referenceQueue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runtime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRuntime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InterruptedException")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printStackTrace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("e")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"testme"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"得到gc回收结果："')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" referenceQueue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("poll")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("strong",[t._v("参考：")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developer.android.com/studio/profile/memory-profiler?hl=zh-cn#performance",target:"_blank",rel:"noopener noreferrer"}},[t._v("1. Allcation Tracker帮助文档"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://www.youkmi.cn/2020/01/01/android-xing-neng-you-hua-zhi-leakcanary-nei-cun-yuan-li-fen-xi/",target:"_blank",rel:"noopener noreferrer"}},[t._v("2. LeakCanary学习"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);