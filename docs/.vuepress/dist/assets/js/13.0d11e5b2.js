(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{365:function(r,e,t){r.exports=t.p+"assets/img/view_chreographer.ae0cf1b0.png"},396:function(r,e,t){"use strict";t.r(e);var a=t(44),n=Object(a.a)({},(function(){var r=this,e=r.$createElement,a=r._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"choreographer机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#choreographer机制"}},[r._v("#")]),r._v(" Choreographer机制")]),r._v(" "),a("p",[r._v("[TOC]")]),r._v(" "),a("h2",{attrs:{id:"一、简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、简介"}},[r._v("#")]),r._v(" 一、简介")]),r._v(" "),a("blockquote",[a("p",[r._v("在Android4.1之后添加了Choreographer机制，用于同Vsync机制配合，统一动画、输入和绘制时机。")]),r._v(" "),a("p",[r._v("Choreographer以每秒60帧的时间，接受垂直信号。你设置的callCack会在下一个frame被渲染时触发。Callback有4种类型，Input、Animation、Draw。动画会根据当前时间查询得的对应的动画执行数据(矩阵数据)，然后执行。")])]),r._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:t(365)}}),r._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/stven_king/article/details/80153400",target:"_blank",rel:"noopener noreferrer"}},[r._v("参考1"),a("OutboundLink")],1)]),r._v(" "),a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/bab0b454e39e",target:"_blank",rel:"noopener noreferrer"}},[r._v("参考2"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);