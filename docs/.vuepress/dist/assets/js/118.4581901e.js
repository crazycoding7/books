(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{492:function(t,a,e){"use strict";e.r(a);var _=e(42),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"ios"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ios"}},[t._v("#")]),t._v(" IOS")]),t._v(" "),e("p",[t._v("[TOC]")]),t._v(" "),e("h2",{attrs:{id:"一、基础知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、基础知识"}},[t._v("#")]),t._v(" 一、基础知识")]),t._v(" "),e("h3",{attrs:{id:"_1-内存管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存管理"}},[t._v("#")]),t._v(" 1. 内存管理")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("内存结构")])]),t._v(" "),e("ol",[e("li",[t._v("**代码区：**代码段是用来存放可执行文件的操作指令（存放函数的二进制代码），也就是说是它是可执行程序在内存种的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。")]),t._v(" "),e("li",[e("strong",[t._v("全局（静态）区")]),t._v("包含下面两个分区：\n"),e("ul",[e("li",[t._v("数据区：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。")]),t._v(" "),e("li",[t._v("BSS区：BSS段包含了程序中未初始化全局变量。")])])]),t._v(" "),e("li",[t._v("**常量区：**常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，")]),t._v(" "),e("li",[e("strong",[t._v("堆（heap）区："),e("strong",[t._v("堆是由")]),t._v("程序员")]),t._v("分配和释放，用于存放进程运行中被动态分配的内存段，它大小并不固定，可动态扩张或缩减。当进程调用alloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用realse释放内存时，被释放的内存从堆中被剔除（堆被缩减），因为我们现在iOS基本都使用ARC来管理对象，所以不用我们程序员来管理，但是我们要知道这个对象存储的位置。")]),t._v(" "),e("li",[e("strong",[t._v("栈（stack）区："),e("strong",[t._v("栈是由")]),t._v("编译器")]),t._v("自动分配并释放，用户存放程序临时创建的局部变量，存放函数的参数值，局部变量等。也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味这在数据段中存放变量）。除此以外在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也回被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上将我们可以把栈看成一个临时数据寄存、交换的内存区。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("ARC内存回收")])]),t._v(" "),e("blockquote",[e("p",[t._v("Automatic Reference Counting，自动引用计数，即ARC。IOS下内存管理的基本思想就是引用计数，通过对象的引用计数来对内存对象的生命周期进行控制。具体到编程时间方面，主要有两种方式：")]),t._v(" "),e("p",[t._v("1：MRR（manual retain-release），人工引用计数，对象的生成、销毁、引用计数的变化都是由开发人员来完成。")]),t._v(" "),e("p",[t._v("2：ARC（Automatic Reference Counting），自动引用计数，只负责对象的生成，其他过程开发人员不再需要关心其销毁，使用方式类似于垃圾回收，但其实质还是引用计数。")])])])]),t._v(" "),e("p",[t._v("​\t在工程中使用ARC非常简单：只需要像往常那样编写代码，只不过永远不写"),e("code",[t._v("retain")]),t._v(","),e("code",[t._v("release")]),t._v("和"),e("code",[t._v("autorelease")]),t._v("三个关键字就好～这是ARC的基本原则。当ARC开启时，编译器将自动在代码合适的地方插入"),e("code",[t._v("retain")]),t._v(", "),e("code",[t._v("release")]),t._v("和"),e("code",[t._v("autorelease")]),t._v("，而作为开发者，完全不需要担心编译器会做错")]),t._v(" "),e("h2",{attrs:{id:"二、其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、其他"}},[t._v("#")]),t._v(" 二、其他")]),t._v(" "),e("h3",{attrs:{id:"_1-mvp-mvvm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-mvp-mvvm"}},[t._v("#")]),t._v(" 1. MVP/MVVM")]),t._v(" "),e("h3",{attrs:{id:"_2-组件化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-组件化"}},[t._v("#")]),t._v(" 2. 组件化")]),t._v(" "),e("br"),t._v(" "),e("ul",[e("li",[t._v("参考")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/dins/p/ios-zu-jian-hua-fang-an.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),e("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=v.exports}}]);